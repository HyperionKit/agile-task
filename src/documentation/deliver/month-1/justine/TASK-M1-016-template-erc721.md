# TASK-M1-016: ERC-721 NFT Template

## Metadata
- Assignee: Justine
- Role: CPOO/Product Lead
- Month: 1 (October 2025)
- Priority: P1
- Status: DONE
- Due Date: 2025-10-18
- Completed Date: 2025-10-18
- Estimated Hours: 8h
- Actual Hours: 

## Problem
NFT projects need secure, gas-efficient contracts. Without templates:
- Common vulnerabilities in minting logic
- Metadata handling varies
- Royalty implementation inconsistent
- Gas costs unpredictable

Current state: No NFT templates. Generation starts from scratch each time.

## Goal
Create production-ready ERC-721 template with metadata, royalties, and common extensions.

## Success Metrics
- Template passes all OpenZeppelin tests
- Supports ERC-2981 royalties
- Gas optimized minting (under 80k per mint)
- On-chain and off-chain metadata support
- 100% Slither pass rate

## Technical Scope

Files to create:
```
packages/templates/
├── erc721/
│   ├── base.sol
│   ├── enumerable.sol
│   ├── royalty.sol
│   ├── burnable.sol
│   ├── soulbound.sol
│   ├── metadata/
│   │   ├── onchain.sol
│   │   └── ipfs.sol
│   └── config.json
└── tests/
    └── erc721.test.ts
```

Dependencies:
- @openzeppelin/contracts
- erc721a (gas optimized)

## Minimal Code

```solidity
// packages/templates/erc721/base.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721URIStorage} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title {{COLLECTION_NAME}}
 * @notice {{COLLECTION_DESCRIPTION}}
 * @dev ERC-721 NFT collection with configurable extensions
 * 
 * Generated by HyperKit
 * Template: ERC721/Base
 */
contract {{CONTRACT_NAME}} is ERC721, ERC721URIStorage, Ownable {
    using Strings for uint256;
    
    /// @notice Maximum supply (0 = unlimited)
    uint256 public immutable maxSupply;
    
    /// @notice Mint price in native token
    uint256 public mintPrice;
    
    /// @notice Base URI for metadata
    string public baseTokenURI;
    
    /// @notice Current token ID counter
    uint256 private _nextTokenId;
    
    /// @notice Mint status
    bool public mintingActive;
    
    error MintingNotActive();
    error MaxSupplyReached();
    error InsufficientPayment();
    error WithdrawFailed();
    
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _maxSupply,
        uint256 _mintPrice,
        string memory _baseURI
    ) ERC721(_name, _symbol) Ownable(msg.sender) {
        maxSupply = _maxSupply;
        mintPrice = _mintPrice;
        baseTokenURI = _baseURI;
    }
    
    /**
     * @notice Mint new NFT
     * @param to Recipient address
     */
    function mint(address to) external payable returns (uint256) {
        if (!mintingActive) revert MintingNotActive();
        if (maxSupply > 0 && _nextTokenId >= maxSupply) revert MaxSupplyReached();
        if (msg.value < mintPrice) revert InsufficientPayment();
        
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
        
        return tokenId;
    }
    
    /**
     * @notice Batch mint (owner only)
     * @param to Recipient address
     * @param quantity Number to mint
     */
    function mintBatch(address to, uint256 quantity) external onlyOwner {
        for (uint256 i = 0; i < quantity; i++) {
            if (maxSupply > 0 && _nextTokenId >= maxSupply) revert MaxSupplyReached();
            uint256 tokenId = _nextTokenId++;
            _safeMint(to, tokenId);
        }
    }
    
    /**
     * @notice Set minting status
     */
    function setMintingActive(bool _active) external onlyOwner {
        mintingActive = _active;
    }
    
    /**
     * @notice Update mint price
     */
    function setMintPrice(uint256 _price) external onlyOwner {
        mintPrice = _price;
    }
    
    /**
     * @notice Update base URI
     */
    function setBaseURI(string memory _baseURI) external onlyOwner {
        baseTokenURI = _baseURI;
    }
    
    /**
     * @notice Withdraw contract balance
     */
    function withdraw() external onlyOwner {
        (bool success, ) = owner().call{value: address(this).balance}("");
        if (!success) revert WithdrawFailed();
    }
    
    /**
     * @notice Total supply minted
     */
    function totalSupply() public view returns (uint256) {
        return _nextTokenId;
    }
    
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        _requireOwned(tokenId);
        
        string memory baseURI = baseTokenURI;
        return bytes(baseURI).length > 0
            ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json"))
            : "";
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
```

```solidity
// packages/templates/erc721/royalty.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721Royalty} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title {{COLLECTION_NAME}}
 * @notice NFT with ERC-2981 royalties
 */
contract {{CONTRACT_NAME}} is ERC721, ERC721Royalty, Ownable {
    uint256 public immutable maxSupply;
    uint256 public mintPrice;
    string public baseTokenURI;
    uint256 private _nextTokenId;
    bool public mintingActive;
    
    error MintingNotActive();
    error MaxSupplyReached();
    error InsufficientPayment();
    
    constructor(
        string memory _name,
        string memory _symbol,
        uint256 _maxSupply,
        uint256 _mintPrice,
        string memory _baseURI,
        address _royaltyReceiver,
        uint96 _royaltyBps
    ) ERC721(_name, _symbol) Ownable(msg.sender) {
        maxSupply = _maxSupply;
        mintPrice = _mintPrice;
        baseTokenURI = _baseURI;
        
        // Set default royalty (e.g., 5% = 500 bps)
        _setDefaultRoyalty(_royaltyReceiver, _royaltyBps);
    }
    
    function mint(address to) external payable returns (uint256) {
        if (!mintingActive) revert MintingNotActive();
        if (maxSupply > 0 && _nextTokenId >= maxSupply) revert MaxSupplyReached();
        if (msg.value < mintPrice) revert InsufficientPayment();
        
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
        return tokenId;
    }
    
    /**
     * @notice Update royalty settings
     * @param receiver Royalty recipient
     * @param feeNumerator Royalty in basis points (e.g., 500 = 5%)
     */
    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external onlyOwner {
        _setDefaultRoyalty(receiver, feeNumerator);
    }
    
    /**
     * @notice Set token-specific royalty
     */
    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) external onlyOwner {
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }
    
    function setMintingActive(bool _active) external onlyOwner {
        mintingActive = _active;
    }
    
    function totalSupply() public view returns (uint256) {
        return _nextTokenId;
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Royalty) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
```

```solidity
// packages/templates/erc721/soulbound.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title {{COLLECTION_NAME}}
 * @notice Non-transferable soulbound NFT
 */
contract {{CONTRACT_NAME}} is ERC721, Ownable {
    uint256 private _nextTokenId;
    string public baseTokenURI;
    
    error SoulboundToken();
    
    constructor(
        string memory _name,
        string memory _symbol,
        string memory _baseURI
    ) ERC721(_name, _symbol) Ownable(msg.sender) {
        baseTokenURI = _baseURI;
    }
    
    /**
     * @notice Issue soulbound token (owner only)
     */
    function issue(address to) external onlyOwner returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
        return tokenId;
    }
    
    /**
     * @notice Revoke soulbound token (owner only)
     */
    function revoke(uint256 tokenId) external onlyOwner {
        _burn(tokenId);
    }
    
    /**
     * @dev Override to prevent transfers
     */
    function _update(address to, uint256 tokenId, address auth) internal override returns (address) {
        address from = _ownerOf(tokenId);
        
        // Allow minting (from = 0) and burning (to = 0)
        if (from != address(0) && to != address(0)) {
            revert SoulboundToken();
        }
        
        return super._update(to, tokenId, auth);
    }
    
    function totalSupply() public view returns (uint256) {
        return _nextTokenId;
    }
}
```

```json
// packages/templates/erc721/config.json
{
    "template": "ERC721",
    "version": "1.0.0",
    "description": "ERC-721 NFT collection with extensions",
    "parameters": {
        "COLLECTION_NAME": {
            "type": "string",
            "required": true,
            "description": "Full collection name",
            "example": "HyperKit Genesis"
        },
        "COLLECTION_SYMBOL": {
            "type": "string",
            "required": true,
            "description": "Collection symbol (3-5 chars)",
            "example": "HKGEN"
        },
        "CONTRACT_NAME": {
            "type": "string",
            "required": true,
            "pattern": "^[A-Z][a-zA-Z0-9]*$"
        },
        "MAX_SUPPLY": {
            "type": "number",
            "required": false,
            "default": 0,
            "description": "Maximum supply (0 = unlimited)"
        },
        "MINT_PRICE": {
            "type": "string",
            "required": false,
            "default": "0",
            "description": "Mint price in ETH"
        },
        "BASE_URI": {
            "type": "string",
            "required": true,
            "description": "Base URI for metadata"
        },
        "ROYALTY_RECEIVER": {
            "type": "address",
            "required": false,
            "description": "Royalty recipient address"
        },
        "ROYALTY_BPS": {
            "type": "number",
            "required": false,
            "default": 500,
            "min": 0,
            "max": 10000,
            "description": "Royalty in basis points (500 = 5%)"
        }
    },
    "extensions": {
        "enumerable": {
            "description": "Token enumeration for marketplaces",
            "file": "enumerable.sol"
        },
        "royalty": {
            "description": "ERC-2981 royalties",
            "file": "royalty.sol"
        },
        "burnable": {
            "description": "Token holders can burn",
            "file": "burnable.sol"
        },
        "soulbound": {
            "description": "Non-transferable tokens",
            "file": "soulbound.sol"
        }
    },
    "defaultExtensions": ["royalty"],
    "gasEstimate": {
        "deployment": 2500000,
        "mint": 80000,
        "transfer": 65000
    }
}
```

## Acceptance Criteria
- [ ] Base ERC-721 template created
- [ ] Mint with payment working
- [ ] Batch minting for owner
- [ ] Royalty extension (ERC-2981) working
- [ ] Soulbound extension working
- [ ] Enumerable extension working
- [ ] Burnable extension working
- [ ] On-chain metadata option
- [ ] IPFS metadata support
- [ ] config.json schema defined
- [ ] Gas under 80k per mint
- [ ] Slither passes all variants
- [ ] Unit tests for all extensions
- [ ] Integration with marketplaces tested

## Dependencies
- TASK-S1-006: Contract Templates Repo

## Progress Log
| Date | Update | Hours |
|------|--------|-------|

## Review Notes


