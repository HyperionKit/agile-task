# TASK-S2-023: DeFi Vault Template (ERC-4626)

## Metadata
- Assignee: Justine
- Role: CPOO/Product Lead
- Sprint: 2
- Priority: P1
- Status: BACKLOG
- Due Date: 2026-01-06
- Estimated Hours: 10h
- Actual Hours: 

## Problem
Yield vaults are complex with many security pitfalls. Without templates:
- Share accounting bugs cause fund loss
- Reentrancy vulnerabilities common
- Slippage handling inconsistent
- Deposit/withdraw timing attacks

Current state: No DeFi templates. High-risk contracts generated from scratch.

## Goal
Create production-ready ERC-4626 tokenized vault with yield strategies and security guards.

## Success Metrics
- Template passes ERC-4626 compliance tests
- No reentrancy vulnerabilities
- Slippage protection included
- Share accounting 100% accurate
- Gas optimized operations

## Technical Scope

Files to create:
```
packages/templates/
├── vault/
│   ├── base.sol
│   ├── strategies/
│   │   ├── compound.sol
│   │   ├── aave.sol
│   │   └── yearn.sol
│   ├── guards/
│   │   ├── slippage.sol
│   │   └── timelock.sol
│   └── config.json
└── tests/
    └── vault.test.ts
```

Dependencies:
- @openzeppelin/contracts
- solmate (gas optimized ERC-4626)

## Minimal Code

```solidity
// packages/templates/vault/base.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC4626} from "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";

/**
 * @title {{VAULT_NAME}}
 * @notice {{VAULT_DESCRIPTION}}
 * @dev ERC-4626 tokenized vault with yield strategy
 * 
 * Generated by HyperKit
 * Template: Vault/Base
 */
contract {{CONTRACT_NAME}} is ERC4626, Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;
    using Math for uint256;
    
    /// @notice Maximum deposit per address (0 = unlimited)
    uint256 public maxDepositPerUser;
    
    /// @notice Total deposit cap (0 = unlimited)
    uint256 public totalDepositCap;
    
    /// @notice Performance fee in basis points (e.g., 1000 = 10%)
    uint256 public performanceFee;
    
    /// @notice Management fee in basis points per year
    uint256 public managementFee;
    
    /// @notice Fee recipient
    address public feeRecipient;
    
    /// @notice Last harvest timestamp
    uint256 public lastHarvest;
    
    /// @notice High water mark for performance fees
    uint256 public highWaterMark;
    
    /// @notice Slippage tolerance in basis points
    uint256 public slippageTolerance = 100; // 1%
    
    // Events
    event Harvested(uint256 profit, uint256 fee);
    event FeesUpdated(uint256 performance, uint256 management);
    event SlippageUpdated(uint256 tolerance);
    
    // Errors
    error DepositExceedsLimit();
    error TotalDepositExceeded();
    error SlippageExceeded();
    error ZeroShares();
    
    constructor(
        IERC20 _asset,
        string memory _name,
        string memory _symbol,
        uint256 _performanceFee,
        uint256 _managementFee,
        address _feeRecipient
    ) ERC4626(_asset) ERC20(_name, _symbol) Ownable(msg.sender) {
        require(_performanceFee <= 3000, "Performance fee too high"); // Max 30%
        require(_managementFee <= 500, "Management fee too high"); // Max 5%
        
        performanceFee = _performanceFee;
        managementFee = _managementFee;
        feeRecipient = _feeRecipient;
        lastHarvest = block.timestamp;
    }
    
    /**
     * @notice Deposit assets with slippage protection
     * @param assets Amount of assets to deposit
     * @param receiver Recipient of shares
     * @param minShares Minimum shares expected
     */
    function depositWithSlippage(
        uint256 assets,
        address receiver,
        uint256 minShares
    ) external nonReentrant whenNotPaused returns (uint256 shares) {
        shares = deposit(assets, receiver);
        if (shares < minShares) revert SlippageExceeded();
    }
    
    /**
     * @notice Withdraw with slippage protection
     */
    function withdrawWithSlippage(
        uint256 assets,
        address receiver,
        address owner,
        uint256 maxShares
    ) external nonReentrant whenNotPaused returns (uint256 shares) {
        shares = withdraw(assets, receiver, owner);
        if (shares > maxShares) revert SlippageExceeded();
    }
    
    /**
     * @notice Redeem shares with slippage protection
     */
    function redeemWithSlippage(
        uint256 shares,
        address receiver,
        address owner,
        uint256 minAssets
    ) external nonReentrant whenNotPaused returns (uint256 assets) {
        assets = redeem(shares, receiver, owner);
        if (assets < minAssets) revert SlippageExceeded();
    }
    
    /**
     * @notice Harvest yields and take fees
     */
    function harvest() external nonReentrant returns (uint256 profit) {
        uint256 totalAssetsBefore = totalAssets();
        
        // Execute strategy (override in derived contracts)
        _harvest();
        
        uint256 totalAssetsAfter = totalAssets();
        
        if (totalAssetsAfter > totalAssetsBefore) {
            profit = totalAssetsAfter - totalAssetsBefore;
            
            // Performance fee on profits above high water mark
            if (totalAssetsAfter > highWaterMark) {
                uint256 profitAboveHWM = totalAssetsAfter - highWaterMark;
                uint256 perfFee = (profitAboveHWM * performanceFee) / 10000;
                
                if (perfFee > 0 && feeRecipient != address(0)) {
                    IERC20(asset()).safeTransfer(feeRecipient, perfFee);
                }
                
                highWaterMark = totalAssetsAfter - perfFee;
                emit Harvested(profit, perfFee);
            }
        }
        
        // Management fee (accrued over time)
        uint256 timeDelta = block.timestamp - lastHarvest;
        uint256 mgmtFee = (totalAssets() * managementFee * timeDelta) / (10000 * 365 days);
        
        if (mgmtFee > 0 && feeRecipient != address(0)) {
            IERC20(asset()).safeTransfer(feeRecipient, mgmtFee);
        }
        
        lastHarvest = block.timestamp;
    }
    
    /**
     * @dev Override to implement yield strategy
     */
    function _harvest() internal virtual {
        // Implement in derived contracts
    }
    
    /**
     * @notice Maximum deposit check
     */
    function maxDeposit(address receiver) public view override returns (uint256) {
        if (paused()) return 0;
        
        uint256 userLimit = maxDepositPerUser > 0
            ? maxDepositPerUser - _userDeposits(receiver)
            : type(uint256).max;
        
        uint256 totalLimit = totalDepositCap > 0
            ? totalDepositCap - totalAssets()
            : type(uint256).max;
        
        return userLimit < totalLimit ? userLimit : totalLimit;
    }
    
    function _userDeposits(address user) internal view returns (uint256) {
        return convertToAssets(balanceOf(user));
    }
    
    /**
     * @notice Update fee settings
     */
    function setFees(uint256 _performance, uint256 _management) external onlyOwner {
        require(_performance <= 3000, "Performance fee too high");
        require(_management <= 500, "Management fee too high");
        
        performanceFee = _performance;
        managementFee = _management;
        
        emit FeesUpdated(_performance, _management);
    }
    
    /**
     * @notice Update deposit caps
     */
    function setCaps(uint256 _perUser, uint256 _total) external onlyOwner {
        maxDepositPerUser = _perUser;
        totalDepositCap = _total;
    }
    
    /**
     * @notice Update slippage tolerance
     */
    function setSlippageTolerance(uint256 _tolerance) external onlyOwner {
        require(_tolerance <= 1000, "Slippage too high"); // Max 10%
        slippageTolerance = _tolerance;
        emit SlippageUpdated(_tolerance);
    }
    
    /**
     * @notice Pause deposits/withdrawals
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @notice Resume operations
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @notice Emergency withdraw (owner only)
     */
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        IERC20(token).safeTransfer(owner(), amount);
    }
}
```

```json
// packages/templates/vault/config.json
{
    "template": "Vault",
    "version": "1.0.0",
    "description": "ERC-4626 tokenized vault with yield strategies",
    "parameters": {
        "VAULT_NAME": {
            "type": "string",
            "required": true,
            "description": "Full vault name",
            "example": "HyperKit USDC Vault"
        },
        "VAULT_SYMBOL": {
            "type": "string",
            "required": true,
            "description": "Vault share token symbol",
            "example": "hkUSDC"
        },
        "CONTRACT_NAME": {
            "type": "string",
            "required": true,
            "pattern": "^[A-Z][a-zA-Z0-9]*$"
        },
        "ASSET_ADDRESS": {
            "type": "address",
            "required": true,
            "description": "Underlying asset address"
        },
        "PERFORMANCE_FEE": {
            "type": "number",
            "required": false,
            "default": 1000,
            "description": "Performance fee in bps (1000 = 10%)"
        },
        "MANAGEMENT_FEE": {
            "type": "number",
            "required": false,
            "default": 200,
            "description": "Annual management fee in bps"
        },
        "FEE_RECIPIENT": {
            "type": "address",
            "required": true,
            "description": "Address to receive fees"
        }
    },
    "strategies": {
        "compound": {
            "description": "Compound V3 lending strategy",
            "file": "strategies/compound.sol"
        },
        "aave": {
            "description": "Aave V3 lending strategy",
            "file": "strategies/aave.sol"
        },
        "yearn": {
            "description": "Yearn V3 vault wrapper",
            "file": "strategies/yearn.sol"
        }
    },
    "guards": {
        "slippage": {
            "description": "Slippage protection on deposits/withdraws",
            "file": "guards/slippage.sol"
        },
        "timelock": {
            "description": "Timelock for parameter changes",
            "file": "guards/timelock.sol"
        }
    },
    "defaultGuards": ["slippage"],
    "gasEstimate": {
        "deployment": 3500000,
        "deposit": 150000,
        "withdraw": 180000,
        "harvest": 250000
    }
}
```

## Acceptance Criteria
- [ ] Base ERC-4626 vault working
- [ ] Share accounting accurate
- [ ] Deposit/withdraw with slippage protection
- [ ] Performance fee calculation
- [ ] Management fee accrual
- [ ] High water mark tracking
- [ ] Deposit caps (per user and total)
- [ ] Pause/unpause functionality
- [ ] Emergency withdraw function
- [ ] ReentrancyGuard on all entry points
- [ ] Compound strategy implemented
- [ ] config.json schema defined
- [ ] Slither passes all checks
- [ ] Unit tests with fuzzing
- [ ] Integration test with mainnet fork

## Dependencies
- TASK-S1-006: Contract Templates Repo
- TASK-S2-021: ERC-20 Template

## Progress Log
| Date | Update | Hours |
|------|--------|-------|

## Review Notes


