# TASK-S5-033: DeFi Templates for Metis & Hyperion

## Metadata
- Assignee: Justine
- Role: CPOO/Product Lead
- Sprint: 5 (Month 3)
- Priority: P0
- Status: IN_PROGRESS
- Due Date: 2026-02-20
- Estimated Hours: 20h
- Actual Hours: 

## Problem
Developers need ready-to-use DeFi templates for Metis and Hyperion networks. Without templates:
- Developers start from scratch each deployment
- Inconsistent contract patterns across ecosystem
- Slower time-to-market for projects
- Higher risk of security vulnerabilities

Current state: Basic templates exist. No Metis/Hyperion-specific DeFi patterns.

## Goal
Deliver 2-3 DeFi templates (vault, staking, swap) for Metis and Hyperion testnets using existing Hyperkit monorepo and HyperionKit npm package.

## Success Metrics
- 3 DeFi templates completed (vault, staking, swap)
- Templates deployed and tested on Metis testnet
- Templates deployed and tested on Hyperion testnet
- 30+ successful testnet deployments
- Documentation published

## Technical Scope

Files to create:
```
packages/templates/
├── defi/
│   ├── vault-metis/
│   │   ├── Vault.sol
│   │   ├── config.json
│   │   └── README.md
│   ├── staking-hyperion/
│   │   ├── StakingPool.sol
│   │   ├── config.json
│   │   └── README.md
│   └── swap-multi/
│       ├── SimpleSwap.sol
│       ├── config.json
│       └── README.md
```

Dependencies:
- @openzeppelin/contracts
- HyperionKit npm package
- Metis SDK

## Minimal Code

```solidity
// packages/templates/defi/vault-metis/Vault.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC4626} from "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title {{VAULT_NAME}}
 * @notice Yield vault optimized for Metis L2
 * @dev ERC-4626 vault with Metis-specific gas optimizations
 * 
 * Generated by HyperKit for Metis Network
 * Template: DeFi/Vault-Metis
 */
contract {{CONTRACT_NAME}} is ERC4626, Ownable {
    using SafeERC20 for IERC20;
    
    uint256 public performanceFee;
    address public feeRecipient;
    uint256 public totalDeposits;
    
    event Harvested(uint256 profit, uint256 fee);
    event FeeUpdated(uint256 newFee);
    
    constructor(
        IERC20 _asset,
        string memory _name,
        string memory _symbol,
        uint256 _performanceFee,
        address _feeRecipient
    ) ERC4626(_asset) ERC20(_name, _symbol) Ownable(msg.sender) {
        require(_performanceFee <= 2000, "Fee too high"); // Max 20%
        performanceFee = _performanceFee;
        feeRecipient = _feeRecipient;
    }
    
    function deposit(uint256 assets, address receiver) public override returns (uint256) {
        totalDeposits += assets;
        return super.deposit(assets, receiver);
    }
    
    function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256) {
        totalDeposits = totalDeposits > assets ? totalDeposits - assets : 0;
        return super.withdraw(assets, receiver, owner);
    }
    
    function harvest() external onlyOwner returns (uint256 profit) {
        uint256 totalAssetsBefore = totalAssets();
        
        // Strategy execution would go here
        _executeStrategy();
        
        uint256 totalAssetsAfter = totalAssets();
        
        if (totalAssetsAfter > totalAssetsBefore) {
            profit = totalAssetsAfter - totalAssetsBefore;
            uint256 fee = (profit * performanceFee) / 10000;
            
            if (fee > 0 && feeRecipient != address(0)) {
                IERC20(asset()).safeTransfer(feeRecipient, fee);
            }
            
            emit Harvested(profit, fee);
        }
    }
    
    function _executeStrategy() internal virtual {
        // Override in derived contracts
    }
    
    function setPerformanceFee(uint256 _fee) external onlyOwner {
        require(_fee <= 2000, "Fee too high");
        performanceFee = _fee;
        emit FeeUpdated(_fee);
    }
}
```

```solidity
// packages/templates/defi/staking-hyperion/StakingPool.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title {{POOL_NAME}}
 * @notice Staking pool for Hyperion network
 * @dev Fixed APR staking with configurable lock periods
 * 
 * Generated by HyperKit for Hyperion Network
 * Template: DeFi/Staking-Hyperion
 */
contract {{CONTRACT_NAME}} is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;
    
    IERC20 public immutable stakingToken;
    IERC20 public immutable rewardToken;
    
    uint256 public rewardRate; // Rewards per second per token staked
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    uint256 public totalStaked;
    uint256 public lockDuration;
    
    struct UserInfo {
        uint256 balance;
        uint256 rewardPerTokenPaid;
        uint256 rewards;
        uint256 lockEnd;
    }
    
    mapping(address => UserInfo) public userInfo;
    
    event Staked(address indexed user, uint256 amount, uint256 lockEnd);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardRateUpdated(uint256 newRate);
    
    error StillLocked();
    error ZeroAmount();
    error InsufficientBalance();
    
    constructor(
        address _stakingToken,
        address _rewardToken,
        uint256 _rewardRate,
        uint256 _lockDuration
    ) Ownable(msg.sender) {
        stakingToken = IERC20(_stakingToken);
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
        lockDuration = _lockDuration;
        lastUpdateTime = block.timestamp;
    }
    
    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = block.timestamp;
        
        if (account != address(0)) {
            userInfo[account].rewards = earned(account);
            userInfo[account].rewardPerTokenPaid = rewardPerTokenStored;
        }
        _;
    }
    
    function rewardPerToken() public view returns (uint256) {
        if (totalStaked == 0) {
            return rewardPerTokenStored;
        }
        return rewardPerTokenStored + 
            ((block.timestamp - lastUpdateTime) * rewardRate * 1e18) / totalStaked;
    }
    
    function earned(address account) public view returns (uint256) {
        UserInfo storage user = userInfo[account];
        return (user.balance * (rewardPerToken() - user.rewardPerTokenPaid)) / 1e18 
            + user.rewards;
    }
    
    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {
        if (amount == 0) revert ZeroAmount();
        
        UserInfo storage user = userInfo[msg.sender];
        
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        
        user.balance += amount;
        user.lockEnd = block.timestamp + lockDuration;
        totalStaked += amount;
        
        emit Staked(msg.sender, amount, user.lockEnd);
    }
    
    function withdraw(uint256 amount) external nonReentrant updateReward(msg.sender) {
        UserInfo storage user = userInfo[msg.sender];
        
        if (amount == 0) revert ZeroAmount();
        if (user.balance < amount) revert InsufficientBalance();
        if (block.timestamp < user.lockEnd) revert StillLocked();
        
        user.balance -= amount;
        totalStaked -= amount;
        
        stakingToken.safeTransfer(msg.sender, amount);
        
        emit Withdrawn(msg.sender, amount);
    }
    
    function claimReward() external nonReentrant updateReward(msg.sender) {
        UserInfo storage user = userInfo[msg.sender];
        uint256 reward = user.rewards;
        
        if (reward > 0) {
            user.rewards = 0;
            rewardToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }
    
    function setRewardRate(uint256 _rate) external onlyOwner updateReward(address(0)) {
        rewardRate = _rate;
        emit RewardRateUpdated(_rate);
    }
    
    function setLockDuration(uint256 _duration) external onlyOwner {
        lockDuration = _duration;
    }
}
```

```json
// packages/templates/defi/vault-metis/config.json
{
    "template": "DeFi/Vault-Metis",
    "version": "1.0.0",
    "network": ["metis", "metis-testnet"],
    "description": "ERC-4626 yield vault optimized for Metis L2",
    "parameters": {
        "VAULT_NAME": {
            "type": "string",
            "required": true,
            "example": "Metis USDC Vault"
        },
        "VAULT_SYMBOL": {
            "type": "string",
            "required": true,
            "example": "mUSDC"
        },
        "CONTRACT_NAME": {
            "type": "string",
            "required": true,
            "pattern": "^[A-Z][a-zA-Z0-9]*$"
        },
        "ASSET_ADDRESS": {
            "type": "address",
            "required": true,
            "description": "Underlying asset address"
        },
        "PERFORMANCE_FEE": {
            "type": "number",
            "required": false,
            "default": 1000,
            "description": "Performance fee in bps (1000 = 10%)"
        },
        "FEE_RECIPIENT": {
            "type": "address",
            "required": true
        }
    },
    "safetyChecks": [
        "admin_is_multisig",
        "fee_within_limits",
        "asset_is_valid_erc20"
    ],
    "gasEstimate": {
        "deployment": 2500000,
        "deposit": 120000,
        "withdraw": 150000
    }
}
```

## Acceptance Criteria
- [ ] Vault template for Metis completed
- [ ] Staking pool template for Hyperion completed
- [ ] Simple swap template (multi-network) completed
- [ ] config.json for each template
- [ ] Safety checks integrated (admin EOA warning, fee limits)
- [ ] Templates integrated with HyperAgent prompts
- [ ] Dashboard UI for template selection
- [ ] Tested on Metis testnet (10+ deployments)
- [ ] Tested on Hyperion testnet (10+ deployments)
- [ ] Documentation with usage examples
- [ ] Code validation passing

## Dependencies
- TASK-S2-023: DeFi Vault Template (ERC-4626)
- TASK-S3-024: API /builds Endpoint

## Progress Log
| Date | Update | Hours |
|------|--------|-------|

## Review Notes
Month 3 Hyperion Milestone - DeFi Templates

